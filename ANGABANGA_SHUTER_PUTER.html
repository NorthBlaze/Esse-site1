<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Бильярд</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #2a2a2a;
        }
        canvas {
            display: block;
            margin: auto;
            background-color: green;
            border: 10px solid #804000;
            border-radius: 15px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
    <script>
        const { Engine, Render, World, Bodies, Body, Events } = Matter;

        const canvas = document.getElementById('gameCanvas');
        canvas.width = window.innerWidth * 0.8;
        canvas.height = window.innerHeight * 0.8;

        const engine = Engine.create();
        engine.world.gravity.y = 0; // Отключаем гравитацию

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvas.width,
                height: canvas.height,
                background: 'green',
                wireframes: false
            }
        });

        const tableWidth = canvas.width;
        const tableHeight = canvas.height;

        const pocketRadius = 20;

        const pockets = [
            { x: pocketRadius, y: pocketRadius },
            { x: tableWidth / 2, y: pocketRadius },
            { x: tableWidth - pocketRadius, y: pocketRadius },
            { x: pocketRadius, y: tableHeight - pocketRadius },
            { x: tableWidth / 2, y: tableHeight - pocketRadius },
            { x: tableWidth - pocketRadius, y: tableHeight - pocketRadius }
        ];

        const balls = [];
        const ballRadius = 15;

        let isDragging = false;
        let dragStart = null;
        let cueBall = null;

        function createBalls() {
            // Белый шар
            cueBall = Bodies.circle(tableWidth / 4, tableHeight / 2, ballRadius, {
                label: 'cueBall',
                restitution: 0.9,
                friction: 0.02,
                frictionAir: 0.02,
                render: { fillStyle: 'white' }
            });
            balls.push(cueBall);

            // Цветные шары
            for (let i = 0; i < 15; i++) {
                const x = tableWidth / 1.5 + (i % 5) * (ballRadius * 2 + 5);
                const y = tableHeight / 2 + (Math.floor(i / 5) - 1) * (ballRadius * 2 + 5);
                balls.push(Bodies.circle(x, y, ballRadius, {
                    label: `ball${i + 1}`,
                    restitution: 0.9,
                    friction: 0.02,
                    frictionAir: 0.02,
                    render: { fillStyle: i % 2 === 0 ? 'red' : 'yellow' }
                }));
            }
        }

        const walls = [
            // Бортики стола
            Bodies.rectangle(tableWidth / 2, -10, tableWidth, 20, { isStatic: true }),
            Bodies.rectangle(tableWidth / 2, tableHeight + 10, tableWidth, 20, { isStatic: true }),
            Bodies.rectangle(-10, tableHeight / 2, 20, tableHeight, { isStatic: true }),
            Bodies.rectangle(tableWidth + 10, tableHeight / 2, 20, tableHeight, { isStatic: true })
        ];

        function createPockets() {
            pockets.forEach(pocket => {
                World.add(engine.world, Bodies.circle(pocket.x, pocket.y, pocketRadius, {
                    isStatic: true,
                    isSensor: true,
                    render: { fillStyle: 'black' }
                }));
            });
        }

        canvas.addEventListener('mousedown', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const dx = mouseX - cueBall.position.x;
            const dy = mouseY - cueBall.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= ballRadius) {
                isDragging = true;
                dragStart = { x: mouseX, y: mouseY };
            }
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const dx = dragStart.x - mouseX;
                const dy = dragStart.y - mouseY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const angle = Math.atan2(dy, dx);

                // Рисуем стрелку траектории
                const arrowLength = Math.min(distance, 100); // Ограничиваем длину стрелки
                const arrowEndX = cueBall.position.x + Math.cos(angle) * arrowLength;
                const arrowEndY = cueBall.position.y + Math.sin(angle) * arrowLength;

                const context = render.context;
                context.clearRect(0, 0, canvas.width, canvas.height);
                Render.world(render);

                context.beginPath();
                context.moveTo(cueBall.position.x, cueBall.position.y);
                context.lineTo(arrowEndX, arrowEndY);
                context.strokeStyle = 'white';
                context.lineWidth = 2;
                context.stroke();
            }
        });

        canvas.addEventListener('mouseup', (event) => {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const dx = dragStart.x - mouseX;
                const dy = dragStart.y - mouseY;

                // Ограничиваем силу удара
                const maxForce = 0.03;
                const forceX = Math.max(Math.min(dx * 0.002, maxForce), -maxForce);
                const forceY = Math.max(Math.min(dy * 0.002, maxForce), -maxForce);

                Body.applyForce(cueBall, cueBall.position, {
                    x: forceX,
                    y: forceY
                });

                isDragging = false;
                dragStart = null;

                const context = render.context;
                context.clearRect(0, 0, canvas.width, canvas.height);
                Render.world(render);
            }
        });

        createBalls();
        createPockets();
        World.add(engine.world, [...balls, ...walls]);

        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;

                // Проверяем попадание в лузы
                pockets.forEach(pocket => {
                    if (Matter.SAT.collides(bodyA, pocket).collided ||
                        Matter.SAT.collides(bodyB, pocket).collided) {
                        if (bodyA === cueBall || bodyB === cueBall) {
                            // Если белый мяч попадает в лузу, возвращаем его
                            Body.setPosition(cueBall, { x: tableWidth / 4, y: tableHeight / 2 });
                            Body.setVelocity(cueBall, { x: 0, y: 0 });
                        } else {
                            // Удаляем другие шары
                            World.remove(engine.world, bodyA.label !== 'cueBall' ? bodyA : bodyB);
                        }
                    }
                });
            });
        });

        Render.run(render);
        Engine.run(engine);
    </script>
</body>
</html>
